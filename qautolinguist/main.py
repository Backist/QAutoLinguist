"""Traslator manager - Provides some functions to handle the process of making .ts files, 
using pyside6-lupdate and pyside6-lrelease


pyside6-lupdate - Translation File Generator for PySide6 Applications
=======================================================================
BASIC SYNTAX:
  pyside6-lupdate [OPTIONS] source_file -ts <path>

  source_file:    Source file (e.g., .py or .ui).  [pyside6-lupdate can be used with both .ui and .py files.]
  path: Generated translation file location. Pylupdate will create a file if the localtion doesn-t point to a file

OPTIONS:
  -no-obsolete:     Do not include obsolete translations in the .ts file.
  -locations:      Include location information in the .ts file.
  -recursive:      Search recursively in directories.
  -source-language: Define the source language.

ADDITIONAL COMMANDS:
  --version: Show the tool version.
  --help:    Display help information.
  
This .ts file can be translated using tools like pyside6-lrelease to generate binary translation files (.qm) used by the application.

Keep in mind that, in the context of internationalization in Qt, translation files (.ts) are generated from source files, 
and then they are compiled into binary translation files (.qm). These binary files are used to provide translation at runtime.
=======================================================================

pyside6-lrelease - PySide6 Translation File Compiler
=======================================================================
BASIC SYNTAX:
  pyside6-lrelease translation_file -qm compiled_translation_file

  translation_file:           Translation file (.ts) generated by pyside6-lupdate.
  compiled_translation_file:  Compiled binary translation file (.qm).

MAIN OPTIONS:
  -compress:      Compress the translation data to reduce the file size.
  -removeidentical: Remove identical duplicate translations.

ADDITIONAL COMMANDS:
  --version: Show the tool version.
  --help:    Display help information.

USAGE:
  pyside6-lrelease is used to compile translation files (.ts) generated by pyside6-lupdate into binary translation files (.qm).

  Example:
    pyside6-lrelease form.ts -qm form.qm

This command will compile the translation file form.ts into the binary file form.qm.
=======================================================================


When using both pyside6-lupdate and pyside6-lrelease in a translation workflow, the process typically involves the following steps:

1. **Generate Translation File (.ts):**
   - Use pyside6-lupdate to generate a translation file (.ts) from source files (e.g., .py or .ui).

     Example:
     ```bash
     pyside6-lupdate source_file -ts translation_file
     ```
2. **Translate (.ts) File:**
   - Open the generated .ts file with a translation tool, such as Qt Linguist, and provide translations for each string.
3. **Compile Translation (.ts) to Binary (.qm):**
   - Use pyside6-lrelease to compile the translated .ts file into a binary translation file (.qm).
   
     Example:
     ```bash
     pyside6-lrelease translation_file.ts -qm compiled_translation_file.qm
     ```
     
4. **Use Compiled (.qm) File:**
   - Integrate the compiled .qm files with your PySide6 application to enable runtime translation.

The compiled .qm files are used by PySide6 to provide translations for the application's interface at runtime. 
This workflow allows for the separation of translation concerns from the application's source code.
"""            
import xml.etree.ElementTree as ET
import shutil
import subprocess
import rtoml
from models.parser import ArgParser
from models.translator import Translator
from pathlib import Path
from typing import Iterable, Optional, Self
from types import MappingProxyType              # crear vistas (no modificables) de un diccionario (proxy)
from time import time, strftime


__all__: list = ["QAutoTranslator"]



class QAutoTranslator:
    
    _TS_EXT = ".ts"       #Explicit written
    _TOML_EXT = ".toml"   #Explicit written
    _QM_EXT = ".qm"       #Explicit written
    
    
    def __init__(
        self,
        source_file: str,                           # .ui | .py file to search for "tr" funcs
        available_locales: list,                    # locales to make a translation file for each one, MUST BE <xx_XX> type locale
        translations_folder: str    = None,         # folder to save translations. IF NONE, CREATE A NEW DIR IN CWD
        default_locale: str         = "en_EN",      # reference locale, took as a reference to make other translations 
        auto_translate: bool        = True,         # Requires internet.
        debug_mode: bool            = False,        # Enabled debug logging
        _verbose: bool              = False         # Verbose all called private methods
    ):
        
        if not self._validate_locales(available_locales):
            raise TypeError(
                DebugLogs.error("Available locales contains a non valid type locale")
            )
            
        if not self._validate_locales(default_locale):   
            raise TypeError(
                DebugLogs.error(f"'{default_locale}' is not a valid locale. Locale must be of type <xx_xx>.")
            ) 
        if self.default_locale in self.available_locales:
            self.available_locales = [locale for locale in available_locales if default_locale not in available_locales]          # Removing reference locale -> All translations are created from default_location
        self.available_locales = available_locales
        self.default_locale = default_locale
        
        
        if translations_folder is None:
            translations_folder = Path() / "translations"                                   # If None, create new one to save translations in CWD
            self.translations_folder = self._init_dir(translations_folder, exist_ok=True)   # creating empty dir, it doesn-t exist for now
        else:
            self.translations_folder = self._init_dir(translations_folder, create_empty=False, strict=True)


        translatables_folder = self.translations_folder / "translatables"                  # Make child of translation folder
        self.translatables_folder = self._init_dir(translatables_folder, exist_ok=True)    # creating empty dir to initialize it

        qmfiles_folder = self.translations_folder / "qm_files"                             # Make child of translation folder
        self.qmfiles_folder = self._init_dir(qmfiles_folder, exist_ok=True)                # creating empty dir to initialize it
            
            
        self.source_file: Path = self._init_file(source_file, create_empty=False, strict=True)
        self.ts_reference_file = self.translations_folder / f"{self.default_locale}{self._TS_EXT}"  
        self.auto_translate                     = auto_translate
        self.trmap: dict[str, list[Path]]       = {locale: [] for locale in self.available_locales}     # dict[str (locale), 
                                                                                                        # [Path<translation file (.ts)>, Path <translatable> (.tsf), Path <qm_file>]
        self.secure_trmap: dict[str, list[Path]] = MappingProxyType(self.trmap)
        self.debug_mode: bool                   = debug_mode                                            # If true, prints functions states
        self._verbose: bool                     = _verbose                                              # If true and debug enabled, verbose debugs
        self.__build_done: bool                 = False                                                 # trade variable
    



    #& ----------  INTERNAL FUNCTIONS  ----------

    @staticmethod
    def _validate_locales(locales: list, valid_locales: list = None):
        if isinstance(locales, str):
            return "_" in locales and locales[:locales.find("_")].upper() == locales[locales.find("_")+1:]
        elif isinstance(locales, Iterable):
            if valid_locales:
                return all(locale in valid_locales for locale in locales)     
            return all(QAutoTranslator._validate_locales(locale) for locale in locales)     #recursion here

    @staticmethod    
    def _validate_options(options: list, valid_options: list = None):
        if isinstance(options, str):
            return "-" in options
        elif isinstance(options, Iterable):
            if valid_options:
                return all(option in valid_options for option in options)     
            return all(QAutoTranslator._validate_options(option) for option in options)       #recursion here
    
    @staticmethod
    def _init_dir(loc: str, create_empty: bool = True, parents: bool = True, exist_ok: bool = True, strict: bool = False) -> Path: # when strict=True raises FileNotFoundError
        """Create a ``Path`` object with ``loc`` and try to create an empty dir if ``mkdir=True``\n
        NOTE: ``Path object can be passed to loc, but unless you want to create an empty dir, this funcion will be useless,
        since it will return the resolved Path only``\n
        The aim of that function is to transform loc to Path object, caching exceptions, and also allowing to initialize it by 
        creating the directory
        """ 
        if not isinstance(loc, Path):  
            loc = Path(loc)
        if create_empty:
            try:
                loc.mkdir(parents, exist_ok)
            except Exception as e:
                raise OSError(
                    DebugLogs.error(
                        f"Could not be created directory: {loc}. Detailed error: {e}"
                    )
                ) from e
        return loc.resolve(strict)      # when strict=True raises FileNotFoundError
    
    @staticmethod
    def _init_file(loc: str, create_empty: bool = True, exist_ok: bool = True, strict: bool = False) -> Path:
        """Create a ``Path`` object with ``loc``, normalize it and try to create an empty file if ``mkfile=True``\n
        NOTE: ``Path object can be passed to loc, but unless you want to create an empty file, this funcion will be useless,
        since it will return the resolved Path only``\n
        The aim of that function is to transform loc to Path object, caching exceptions, and also allowing to initialize it by 
        creating the file
        """
        if not isinstance(loc, Path):  
            loc = Path(loc)
        if create_empty:
            try:
                loc.touch(exist_ok=exist_ok)
                return loc
            except Exception as e:
                raise OSError(
                    DebugLogs.error(
                        f"Could not be created file: {loc}. Detailed error: {e}"
                    )
                ) from e
        return loc.resolve(strict)
        
    def setup_(self):
        
    # create_ts_reference_file se llama 1 vez, solo crea un archivo de referencia .ts del que parten los demás .ts (copias)
    def create_ts_reference_file(self, options: list = None) -> None:   
        """
        Creates a .ts reference file using `pyside6-lupdate` command.

        Args:
            options: Optional list of options to pass to `pyside6-lupdate` command (list).
        Raises:
            TypeError: If the options list is invalid.
            OSError: If there is an error during the creation of the .ts reference file.
        Returns:
            None
        """
        options = options or ["-no-obsolete"]
        if not self._validate_options(options):
            raise TypeError(
                DebugLogs.error(
                    "Invalid options. Check options list and make sure there are valid options to pass to `pyside6-lupdate`"
                )
            )
        command = ["pyside6-lupdate", " ".join(options), str(self.source_file), "-ts", str(self.ts_reference_file)] 
        try:
            subprocess.run(command, check=True, capture_output=True, text=True)
        except subprocess.CalledProcessError as e:
            raise OSError(
                DebugLogs.error(
                    f"Error durante la creación del .ts de referencia {self.ts_reference_file}. Detailed error: {e.stdout}"
                )
            ) from e       
        if self.debug_mode:
            echo(DebugLogs.info(f"Archivo de referencia de traduccion creado correctamente en: {self.ts_reference_file}."))
            
               
    def _extract_translation_sources(self, ts_file: Path) -> list:
        """
        Extracts the sources from a Qt translation (.ts) file.
        ### Args:
            ts_file (Path): The path to the Qt translation file. Can be either Path object or str
        ### Returns:
            list
        """
        try:
            tree = ET.parse(ts_file)
            root = tree.getroot()
        except Exception as e:
            raise OSError(
                DebugLogs.error(
                    f"Error durante el proceso de extracción de las fuentes del archivo: {ts_file}. Detailed error: {e}"
                )
            ) from e
        if self.debug_mode and self._verbose:
            echo(DebugLogs.verbose(f"Sources extracted correctly from file {ts_file}"))
        return [message.text.strip() for message in root.findall(".//message/source")]


    def _create_translatable(self, ts_file: Path):  
        """
        Creates a plain translatable file from a .ts file.

        Args:
            ts_file: The path to the .ts file (Path).
        Returns:
            The path to the created plain translatable file (Path).
        """

        extracted_source_fonts = self._extract_translation_sources(ts_file) 
        name = ts_file.stem+self._TOML_EXT                               # tanto los translatable files como los translations tienen el mismo nombre  
        composed_path = self.translatables_folder / name                # name= <locale>.tsf
        try: 
            TsfComposer.create(composed_path, extracted_source_fonts, [], self.default_locale)   # No se anaden las traducciones, hasta este punto no las tenemos aún
        except Exception as e:              
            raise OSError(
                DebugLogs.error(
                    f"Error al crear el translatable desde {ts_file}. Detailed error -> {e}"
                )
            ) from e              
        if self.debug_mode and self._verbose:
            echo(DebugLogs.verbose(f"Translatable file created correctly from {ts_file}"))
        return composed_path   
        
        
    def _translatable2list(self, _file: Path): 
        """
        Calls TsfComposer.decompose_tsf() that returns the translations

        ### Args:
            _file: The path to the plain text file to be converted.
        ### Returns:
            A list of strings, where each string represents a line in the plain text file.
        ### Raises:
            AssertionError: If the provided _file does not exist or is not a file.
            IOError: If there is an error reading the plain text file.
        """
        #! TENEMOS QUE LLAMAR A TSFCOMPOSER.GET_TRANSLATIONS()
        try:
            with _file.open("r", encoding="utf-8") as _f: 
                l = [line.strip() for line in _f.readlines()]              
        except Exception as e:
            raise OSError(
                DebugLogs.error(
                    f"No se pudo crear la lista de sources de {_file}. Detailed error: {e}"
                )
            ) from e
        if self.debug_mode and self._verbose:
            echo(DebugLogs.verbose(f"Correctly created list with sources of translatable file {_file}"))
        return l 

              
    def _insert_translated_sources(self, ts_file: Path, translatable_file: Path):
        """
        Insert translated sources into a Qt translation source file (.ts).

        ### Args:
            ts_file (str): The path to the Qt translation source file (.ts)
            translatable_file (str): The path to the file containing the translated sources.
        ### Raises:
            ValueError: If the number of translations does not match the existing translations in the .ts file.
            Exception: If there is an error processing the file.
        ### Returns:
            None
        """     
        try:
            self._process_insertion_from_source(ts_file, translatable_file)        # Extract method here. We are NEVER NESTER DEVELOPER
        except Exception as e:
            raise OSError(
                DebugLogs.error(
                    f"No se pudo insertar las sources desde {ts_file}. Detailed error: {e}"
                )
            ) from e
        if self.debug_mode and self._verbose:
            echo(DebugLogs.verbose(f"Fuentes de {translatable_file} insertadas correctamente en {ts_file}"))

    def _process_insertion_from_source(self, ts_file, translatable_file):   
        """
        Processes a .ts file by updating the translations based in sources contanined in translatable_file.
        Args:
            ts_file (str): The path to the .ts file to be processed. (To update <translation> with source)
            translatable_file (str): The path to the translatable file.
        Raises:
            ValueError: If the number of translations in the .ts file does not match the number of translations in the translatable file.
        Returns:
            None
            
        ``NOTE: Method that is called only in _insert_translated_sources()``
        """
        tree = ET.parse(ts_file)
        root = tree.getroot()
        current_translations = root.findall(".//message/translation")
        translations_list = self._translatable2list(translatable_file)
        if len(current_translations) != len(translations_list):                              #verify the number of translations are equal in translations_list and current
            raise ValueError(
                DebugLogs.error(
                    "The number of sources in the translatable does not match the number of sources in the translation file. \n"
                    "NOTE: If the translatables have been translated manually, it is possible that some sources have been deleted or two sources have been joined in one line."
                )
            )
        for idx, translation_tag in enumerate(current_translations):
            translation_tag.attrib["type"] = "Finished"                                      # Cambiar el atributo a type="finished" (se puede obviar)
            translation_tag.text = translations_list[idx]
        tree.write(ts_file, encoding="utf-8", xml_declaration=True)                        


    def _make_qm_file(self,  ts_file: Path, options: list = None) -> None: #ts_file can be Path
        """
        Generate a Qt translation file (.qm) from a Qt translation source file (.ts).

        ### Args:
            ts_file (str): The path to the Qt translation source file (.ts).
            options (list, optional): Additional options to be passed to the pyside6-lrelease command. Defaults to None.
        ### Raises:
            AssertionError: If any option in the options list is not a string or does not start with "--".
        ### Returns:
            None
        """
    
        if options is not None and not self._validate_options(options):
            raise TypeError(
                DebugLogs.error("Invalid options found in options list"
                )
            )
        name = ts_file.stem+self._QM_EXT
        path = self.qmfiles_folder / name
        if options is not None:
            command = ["pyside6-lrelease", " ".join(options), str(ts_file), "-qm", str(path)] 
        else:
            command = ["pyside6-lrelease", str(ts_file), "-qm", str(path)] 
        try:
            subprocess.run(command, check=True, capture_output=True, text=True)
        except subprocess.CalledProcessError as e:
            raise OSError(
                DebugLogs.error(
                    f"No se pudo crear el binario por un error con subprocess. Detailed error: {e.stdout}"
                )
            ) from e
        if self.debug_mode and self._verbose:
            echo(DebugLogs.verbose(f"Binario realizado correctamente para {ts_file}."))
    

    #& ----------  PUBLIC FUNCTIONS  ------------         
    def create_translation_files_from_locales(self):
        for locale in self.available_locales:
            name = locale + self._TS_EXT       # <locale>.ts
            ts_path = self.translations_folder / name
            try:
                shutil.copy(self.ts_reference_file, ts_path)
            except Exception as e:
                raise OSError(
                    DebugLogs.error(
                        f"No se puedo crear el ts para {ts_path}; Check if _create_reference_file() was called to initialize the ts reference file.\n Detailed Error: {e}"
                    )
                ) from e
            self.trmap[locale][0] = ts_path   # entramos a la key=locale (ya creada) y guardamos en idx 0 el ts_file puesto que tsmap es de la forma [ts_file, tsf_file, qm_file] 
        if self.debug_mode: 
            DebugLogs.info(f"Translation files created correctly from {self.ts_reference_file} in {self.translations_folder}") 
            
    def create_translatables_from_locales(self):
        #? Podemos crear también los translatables con los translation files también; Ya están creados.
        for locale in self.available_locales:
            if not self.trmap[locale]:          # Aún no se ha creado los archivos (lista vacia). Suele pasar cuando se llama manualmente al método
                raise ValueError(
                    DebugLogs.error(
                        "Call create_translation_files_from_locales() method to create translation files first."
                    )
                )
            ts_file = self.trmap[locale][0]         # cogemos el Path del translation file ya creado a partir del locale ubicado en idx 0
            tsf_file = self._create_translatable(ts_file)   #los tsf se crean con el ts de cada locale, que por ahora son solo copias con el locale <defaut_locale>
            self.trmap[locale][1] = tsf_file        # guardamos el path en el idx1
        if self.debug_mode: 
            echo(DebugLogs.info(f"Translatable files created created correctly in {self.translatables_folder}"))
    
    def insert_translated_sources(self):
        for ts_file, tsf_file in self.trmap.values():
            if not ts_file or not tsf_file:         # Aún no se ha creado los archivos. Suele pasar cuando se llama manualmente al método
                raise DebugLogs.error(
                    "Translation files have not been created yet. Call create_translation_files_from_locales() and create_translatables_from_locales() in this order."
                )
            self._insert_translated_sources(ts_file, tsf_file)
        if self.debug_mode: 
            echo(DebugLogs.info(f"Translatables inserted corretly in ts files from {self.translatables_folder}"))
            
    def translate_translatables(self, stop_on_failure: bool = False): #param stop_on_failure will pass a bool in to AutoTranslator().translate_from_batch() to raise an exception in case one file 
        
        Translator = AutoTranslator(compatible_with_tsf_files=True)
        source_lang = self.default_locale[:2]
        self.untranslated_translatables = []    # aqui ponemos aquellos que no hallan podido ser traducidos. Lo hacemos atributo de instancia para que accedan los demas metodos
        for tsf_file in self.translatables_paths:
            to_lang = tsf_file.stem[:2]
            try:
                Translator.translate_to(tsf_file, to_lang, source_lang, stop_on_failure=True)
                echo(DebugLogs.info(f"Translatable {tsf_file} translated with success to {to_lang}"))  
            except Exception as e:
                if stop_on_failure:  
                    raise Exception(
                        DebugLogs.error(
                            f"Unable to translate {tsf_file} to {tsf_file.stem[:2]}. Detailed error: {e}"
                        )
                    ) from e
                self.untranslated_translatables.append(tsf_file)
                            
        if self.untranslated_translatables is not None:
            DebugLogs.warning(f"Some files werent able to translate: {self.untranslated_translatables}")
        if self.debug_mode: 
            DebugLogs.info(f"Translatables correctly translated in {self.translatables_folder}")
    
    def make_qm_files(self, options: list = None):      #! ARREGLAR, ahora se crean a partir de un diccionario (self.trmap)
        for locale, files in self.trmap.items():
            ts_file = files[1]
            if self.untranslated_translatables is not None and ts_file not in self.untranslated_translatables:
                self.trmapself._make_qm_file(ts_file, options)
            elif self.debug_mode and self._verbose:
                DebugLogs.verbose(f"Skipped {ts_file}; Raised an error during AutoTranslation.")
        if self.debug_mode:
            echo(DebugLogs.info(f"Binarios realizados correctamente para {ts_file}."))
        
    
    def build(self, clean_build: bool = True, **kwargs):
        """Call all the public methods to make a build.
        If ``clean_build`` is set to True, all directories used to make the build will be removed except the one that contains the binaries.
        """
        if self.__build_done:
            raise Exception(
                DebugLogs.warning("Build has been done before. Use restore() or update() functions instead.")
            )
        DebugLogs.info("Preparing build...")

        try:
            self.create_ts_reference_file()
            self.create_translation_files_from_locales()         
            self.create_translatables_from_locales()   
            if not self.auto_translate:
                DebugLogs.warning(
                    "Build completed with sucess.\n CAUTION: The build is incomplete, manually translates and modifies the .tsf and calls the .remake_qm_files() method"
                )
                # self._make_secure_copy()
                return 
            self.translate_translatables()
            self.insert_translated_sources()
            self.make_qm_files()
        except KeyboardInterrupt:
            DebugLogs.error("Because the build has not been completed, its process has been restored and build() must be called again.") 
            self.restore()          # elimina todos los archivos o directorios creados por build, aparte de limpiar el diccionario.
            return 
        except Exception as e:
                # Clean up self.trmap on failure
            DebugLogs.error(f"Something went wrong during the build. Detailed error: {e}")
            self.restore()          # elimina todos los archivos o directorios creados por build, aparte de limpiar el diccionario.
            return 

        if clean_build:
           self._sanitize_after_build()
        self.__build_done = True
    
    
    def _sanitize_after_build(self):
        """Elimina todos directorios creados durante la build"""
        if self.qmfiles_folder.relative_to(self.translations_folder):
            shutil.move(self.qmfiles_folder, self.translations_folder.parent)      # saca el dir un nivel fuera
        if self.translatables_folder.relative_to(self.translations_folder):        # elimina todo translation folder si translatable_folder se contiene dentro
            shutil.rmtree(self.translations_folder)                                
        else:
            shutil.rmtree(self.translations_folder)                                # sino pues se elimina translations_folder
        
    def restore(self):
        """Borra todo el proceso hecho por .build()
        NOTA: Este método solo podrá llamarse si se ha llamado previamente el método build()
        """
        if not self.__build_done:
            raise Exception(
                DebugLogs.error("No build has been created yet. Create one with the build() function")
            )
        self.reinitiaze()       # Borra el diccionario que contiene las rutas por si build es llamado de nuevo. reinitialize NO BORRA LOS DIRECTORIOS
        self.restore()
        
    
    def reinitiaze(self):
        "Restaura el diccionario que contiene las rutas y eliminando todos los archivos creados PERO NO LOS DIRECTORIOS."
  
        if not self.__build_done:           
            raise Exception(
                DebugLogs.error("No build has been created yet. Create one with the build() function")
            )

        self.trmap = {locale: [] for locale in self.available_locales}      # overwritting new one; Fast and easy peasy :)
        self.trmap_proxy = MappingProxyType(self.trmap)
        self.__build_done = False # update __build_done is case was True
        DebugLogs.info("Restored process done sucessfully")


    def update(self):
        """Elimina todo y vuelve a crear una build. ``Usar este método cuando tienen que ser actualizados los .ts``"""
        self.restore()
        self.build()
        
    def remake_qm_files(self):
        """Crea los binarios de partir de los .ts ya creador. ``Usar este método cuando se han modificado los translatables, usualmente, de forma manual.``
        Esta función llamará a ``insert_translated_sources()`` y ``make_qm_files()``
        """
        if not self.__build_done:
            raise Exception(
                DebugLogs.error("No build has been created yet. Create one with the build() function")
            )
        self.insert_translated_sources()
        self.make_qm_files()


# ----------------------------------------------------------------------
# Create one instance to avoid create more instances 
# ----------------------------------------------------------------------
_inst = QAutoTranslator
QAutoTranslator = _inst



if __name__ == "__main__":

    i = time()
    T = QAutoTranslator(
        source_file="",
        available_locales="",
        auto_translate=True,
        debug_mode=True,
        _verbose=True
    )
    T.build()
    print(f"Tiempo de ejecucción de build() -> {time()-i:.2f}")
    

##EOF