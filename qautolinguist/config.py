import configparser
import helpers
import exceptions
import consts
from dataclasses import dataclass
from functools import lru_cache
from ast import literal_eval      # para convertir listas y otras estructuras de datos de str a su tipo original
from pathlib import Path
from typing import List, Dict, Optional, Union

__all__: list[str] = ["Config"]


@dataclass(init=False, repr=False, eq=False)
class ConfigSectionDefinitions: 
    """
    Class that contains the definitions for each section in .INI file.
    For now, we are using a ``INI_FILE_TEMPLATE`` and this class is not used, but maintained just in case to switch to make .ini with dict
    """
    CONFIG_HEADER_DEFINITION: str = (
        "================================    HEADER    =============================================\n"
        "This file is auto-generated by qautolinguist.\n"
        "Use caution when modifying this file and only modify or fill in the requested attributes.\n"
        "Any unauthorised or improper modification may cause qautolinguist to malfunction.\n"
        "==========================================================================================\n"
    )
    
    CONFIG_OPTIONALS_HEADER: str = (
        "=============================   OPTIONALS    =====================================\n"
        "Usually you will not need to edit this section.\n"
        "Here you can adjust where the generated files are saved and some settings to\n"
        "handle the behaviour of the QAutoLinguist\n"
        "==================================================================================\n"
    )
    
    CONFIG_INTERNAL_HEADER : str = (
        "=============================   INTERNAL    =====================================================\n"
        "Section containing special values and attributes for the correct functioning of QAutoLinguist.\n" 
        "Any changes to these values will prevent QAutoLinguist from working properly.\n"
        "=================================================================================================\n"
    )
    
PARAMS_DESCRIPTION = {
    'source_file': '.ui or .py file to search for "tr" funcs.', 
    'available_languages': 'A list of languages/locales that your aplication will support. Langs or locales can be put either as <xx_XX> or typing the lang directly (english, spanish, etc).', 'default_language': 'Reference locale, took as a reference to make other translations.', 
    'source_files_folder': 'Folder that contains the .ts files (Qt translation Files). If not specified, a folder will be created in CWD where you put the command.', 
    'translations_folder': 'Folder that contains the .qm files (Final translation files that your app will use). If not specified, a folder will be created in CWD where you put the command.', 
    'translatables_folder': 'Folder that contains the .toml files (editable translation files). If not specified, a folder will be created in CWD where you put the command.', 
    'use_default_on_failure': 'When True, translation reference will be use in case one translation in one language fails. When False a FailedTranslation exception wil be raised.', 
    'revise_after_build': 'Allow to see and edit translated translations in case you want to modify some words or phrases after compile the files.', 
    'clean': 'Removes all runtime directories created (translatables & font_files folders) and keeps the folder that contains the final translations. Essentially a clean build.', 
    'debug_mode': 'Displays information about the state of the build.', 
    'verbose': 'Displays more information about the processes done. DEBUG_MODE must be True to enable that option.'
}

INI_FILE_TEMPLATE = """
# =============================   HEADER    =====================================
#This file is auto-generated by qautolinguist. 
#Use caution when modifying this file and only modify or fill in the requested attributes. 
#Any unauthorised or improper modification may cause qautolinguist to malfunction.
# ===============================================================================

[Required]
{source_file_comment}
{source_file}= {source_file_value} 

{default_language_comment}
{default_language}= {default_language_value}   

{available_languages_comment}
{available_languages}= {available_languages_value}


# =============================   OPTIONALS    =====================================
# Usually you will not need to edit this section.
# Here you can adjust where the generated files are saved and some settings to
# handle the behaviour of the QAutoLinguist
# ==================================================================================

[Optionals]
{translations_folder_comment}
{translations_folder}= {translations_folder_value}

{source_files_folder_comment}
{source_files_folder}= {source_files_folder_value}
     
{translatables_folder_comment}
{translatables_folder}= {translatables_folder_value}
        
{use_default_on_failure_comment}
{use_default_on_failure}= {use_default_on_failure_value}     

{revise_after_build_comment}
{revise_after_build}= {revise_after_build_value}      

{clean_comment}
{clean}= {clean_value}            

{debug_mode_comment}
{debug_mode}= {debug_mode_value}               

{verbose_comment}
{verbose}= {verbose_value}   


# =============================   INTERNAL    ====================================================
# Section containing special values and attributes for the correct functioning of QAutoLinguist. 
# Any changes to these values will prevent QAutoLinguist from working properly.
# ================================================================================================

[Internal]
{cwd_comment}
{cwd} = {cwd_value}
"""


#? Pongo los comentarios en el doc de la clase porque hace dos funciones: Explicar que son los parametros de la clase y a la vez ser los comentarios
#? que se pondr√°n en el config.ini
class Config:
    """
    Class that represents a Configuration File and its attributes.
    
    This class only uses ``configparser.ConfigParser`` to read .ini files, not to write.
    """
    COMMENT_PREFIX = "#"
    
    #! Los atributos pedidos son los mismos que pide QAutoLinguist, REVISAR si SON IGUALES SIEMPRE.
    #! Si se modifica PARAMS_DESCRIPTION, QAutoLinguist o este, debemos incorporar los cambios a cada uno, puesto comparten parametros.
    def __init__(
        self,
        source_file:            Union[str, Path],                   # .ui | .py file to search for "tr" funcs
        available_languages:    List[str],             # locales to make a translation file for each one, MUST BE <xx_XX> type locale    
        default_language:       str = "en_EN",         # reference locale, took as a reference to make other translations
        source_files_folder:      Union[str, Path] = None,              #.ts files.  QAutoLinguist will create a folder if not provided in CWD
        translations_folder:    Union[str, Path] = None,              # .qm files.  (same)
        translatables_folder:   Union[str, Path] = None,              #.toml files. (same)
        use_default_on_failure: bool = True,           # Se debe usar la traduccion del default si la de alguno falla. When False a FailedTranslation exception wil be raised
        revise_after_build:     bool = False,          # Permite al usuario ver las traducciones y modificarlas antes de ser compiladas a .qm
        clean:                  bool = True,           # Elimina todos los directorios y archivo de configuracion creados excepto la de las traducciones. 
        debug_mode:             bool = False,          # Enabled debug logging
        verbose:                bool = False,          # Verbose all called private methods  
    ):  
        self.source_file               = source_file               
        self.available_languages       = available_languages
        self.default_language          = default_language
        self.source_files_folder       = source_files_folder
        self.translations_folder       = translations_folder
        self.translatables_folder      = translatables_folder
        self.use_default_on_failure    = use_default_on_failure
        self.revise_after_build        = revise_after_build
        self.clean                     = clean
        self.debug_mode                = debug_mode
        self.verbose                   = verbose
        
        self.cwd = Path()

        self._parser = configparser.ConfigParser(allow_no_value=True)
        self.CONFIG_FILE_CREATED = False



    #& ----------------------------------- INTERNAL FUNCTIONS -------------------------------------
    #* [DEPRECATED] Esta funcion se encargaba de parsear el __doc__ donde estaban las explicaciones de los parametros. 
    #* en su lugar ahora usamos un diccionario estatico que esta en consts.PARAMS_DESCRIPTION
    # def _get_comments(self): 
    #     """
    #     Usa el docstring de la clase para extraer los comentarios de los parametros de la clase y se retorna
    #     un dict de la forma ``dict[key: comment]``"""
    #     from re import findall 
    #     # comments match the form => :param <name_attr>: ``comment``
    #     params_match = findall(r':param\s+([\w_]+):\s+``(.+?)``', Config.__doc__) # Toma los comentarios del __doc__ de la clase
    #     return dict(params_match)
    
    
    def _process_dict_data(self):
        """Revuelve un diccinario con claves ``param:comment`` tomando ``self.__dict__`` y ``PARAMS_DESCRIPTION``""" 
        param_comments = PARAMS_DESCRIPTION  #! Importamos el diccionario estatico que contiene los comentarios, es de la forma dict[param: comment]
        return {
            key: (
                helpers.stringfy(value),    # convertimos el valor a str (configparser convierte todo a str)
                helpers.fit_string(param_comments.get(key, ""), split_size=75, preffix=self.COMMENT_PREFIX)      # si no se encuentra el parametro en el diccionario de comentarios, ese parametro no tiene comentario
                ) 
            for key,value in self.__dict__.items() if not key.startswith("_") # consideramos parametros validos aquellos que no sean privados (que se toman como necesarios para que la clase funcione)
        }

    def _format_dict_data(self):
        """
        A partir del diccionario devuelto por self._process_dict_data, se reformatea el diccionario en la forma:
        Pasamos de ``dict[key: (value, comment)]`` a ``dict[key: key, key_value: value, key_comment: comment]``
        El diccionario devuelto es el que se pasa para formatear el INI_FILE_TEMPLATE especificado arriba, que corresponde al formato
        est√°tico del archivo de configuracion
        """
        dict_data = self._process_dict_data()           # structure => {key: (value, comment)}
        d = {}
        for key, (value, comment) in dict_data.items():
            d[key] = key
            d[f"{key}_value"] = value
            d[f"{key}_comment"] = comment
        return d
    
    def _process_template(self):
        return INI_FILE_TEMPLATE.format(**self._format_dict_data())   
    
    def _conv_value_type(self, raw, original):
        raw             = raw.strip().lower()
        converter       = None
        positive_states = {"true", "on", "yes", "1"}
        negative_states = {"false", "off", "no", "0"}
        
        if not raw:     # si es una cadena vacia, devolvemos None
            return None
        if isinstance(original, bool):
            if raw in positive_states:
                return True
            if raw in negative_states:
                return False
            else: 
                raise exceptions.ConfigWrongParamFormat(f"Failed trying to format {raw!r} into a bool type, valid boolean formats are {positive_states, negative_states}")
            
        elif isinstance(original, Path):
            try:
                return  Path(raw).resolve()
            except OSError:
                raise exceptions.ConfigWrongParamFormat(f"Failed trying to format {raw!r} into a Path type. {raw!r} must contain a valid system-path.")
        elif isinstance(original, str):
            return raw   
        elif isinstance(original, int):
            converter = int     # raises ValueError on failure
        elif isinstance(original, float):
            converter = float  # raises ValueError on failure
        elif isinstance(original, (list, tuple)):
            converter = literal_eval           # para convertir listas y otras estructuras de datos de str a su tipo original
            # raises SyntaxError on failure
        try:
            return converter(raw) 
        except (ValueError, SyntaxError, OSError) as e:
            raise exceptions.ConfigWrongParamFormat(f"Cant convert {raw!r} to python datatype, invalid param. Tried to convert param to {converter.__name__!r}. \nDetailed error: {e}")
        
    def _check_missing_params(self, data: Dict[str, str]):
        """Toma un diccionario y comprueba que todas las llaves tengan un valor no vacio o nulo"""
        for option,value in data.items():
            if not value:
                raise exceptions.UncompletedConfig(f"{option!r} param is missing, no value for {option!r} found.")
            
    def _process_read(self):
        """Toma el proxy obtenido de ``ConfigParser.items()`` y devuelve el tipo de los parametros a tipos de Python"""
        joined_dict = self._get_items_from_load()                   # devuelve un dict[section: {option1:value, option2:value, ...}]
        final_dict  = {}
        
        self._check_missing_params(joined_dict["Required"])   # queremos saber si todos los parametros de [Required] estan completos
        # raisea exceptions.UncompletedConfig si alguno esta incompleto
        
        for options in joined_dict.values():                        # despreciamos section aqui, no nos hace falta
            for key,value in options.items():
                final_dict[key] = self._conv_value_type(value, self.__dict__[key])   # pasamos el valor en string y el valor original 
        return final_dict
    
    def _get_items_from_load(self):
        """
        Toma el view proporcionado por ``ConfigParser.read`` y lo transforma a un diccionario de la forma 
        ``dict[section: {option1:value, option2:value, ...}]``
        """
        return {section: dict(self._parser.items(section)) for section in self._parser.sections()}
    
    
    #& ----------------------------------- PUBLIC FUNCTIONS -------------------------------------
    def create(self, loc: Union[str, Path]):
        self.config_path = Path(loc).resolve() #? Creamos un atributo de clase para compartir la ruta del configFile.
        if self.CONFIG_FILE_CREATED or self.config_path.exists():
            raise exceptions.ConfigFileAlreadyCreated(f"Config File already created in {self.config_path}. If you created an empty one, delete it, otherwise run ``qautolinguist build run`` if you have already edited the file.")
        
        processed_template = self._process_template()    #creamos una instancia con los valores vacios y procesamos el template con esos
        with self.config_path.open("w", encoding="utf-8") as file_:
            file_.write(processed_template)
        
        self.CONFIG_FILE_CREATED = True
        return self.config_path
    
    
    def load_config(self, loc: Optional[Union[str, Path]] = None):
        loc = Path(loc).resolve() if loc else None

        if loc is not None and loc.exists():                                # si el path pasado es valido, seguimos adelante
            pass
        elif self.config_path or self.config_path.exists():                 # se ha utilizado create en el mismo tiempo de ejecuccion
            loc = self.config_path
        elif consts.CMD_CWD.joinpath(self.config_path.name).exists():       # se encuentra en el CWD del comando
            loc = consts.CMD_CWD.joinpath(self.config_path.name)
        
        if loc is not None:
            self._parser.read(loc, encoding="utf-8")
            return self._process_read()

        raise exceptions.MissingConfigFile("Unable to find Config file. Create a config file with Config.create() or pass a valid path.")
            
            
if __name__ == "__main__":
    
    c = Config("C:", ["spanish", "spanish", "spanish", "spanish", "spanish","spanish", "spanish"])
    p = c.create(consts.RUNTIME_FOLDER / consts.CONFIG_FILENAME)
    print(c.load_config())
    
    
