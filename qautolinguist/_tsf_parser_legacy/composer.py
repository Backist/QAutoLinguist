from TsfParser import Parser
from pathlib import Path
from typing import Iterable

class TsfComposer:
    
    HEADER_DEFINITION: str = (
        "This file is auto-generated by TsfComposer. "
        "It contains the translation sources of the .ts files (translation files); "
        "each line is a unique translation. "
        "Please, if you are going to review or modify its content, do it with caution, "
        "any unwanted modification will affect the creation of the binaries.^¤^"
    )
    DECLARATION_TYPE:                   str   = "*[{}: {}]"
    GROUP_IDENTIFICATOR_SELECTOR:       str   = "@[Group:{}]"
    GROUP_SPECIFIC_SELECTOR:            str   = "[{}::{}]" # Field, group ID
    GROUP_PARTIAL_SEPARATOR:            str   = "--|"
    COMMENT_SYMBOL:                     str   = "!#!"
    LINES_SEPARATOR:                    str   = "="         # Delimina los bloques de codigo
    NEWLINE:                            str   = "\n"        #? Si cambiamos esto a uno sin cambio de linea podemos tener un archivo de tamano mas pequeno.
    BOTTOM_PADDING_TOP_SECTION:         int   = 4           # espacio entre la marca de agua y las traducciones
    PADDING_BETWEEN_GROUPS:             int   = 2           # espacio entre los grupos en main_section
    EOF:                                str = ";;.EOF"
    # UNIVERSAL_SELECTOR:         str   = "*"       
    # GENERIC_SELECTOR:           str   = "&"       #
    # SEPARATOR:                  str   = "*_*"

    
    @staticmethod
    def create(path: Path, sources: Iterable, translations: Iterable, source_lang: str, encoding: str = "utf-8"):
        build_header        = TsfComposer._process_header()
        build_declarations  = TsfComposer._process_declarations(source_lang)
        top_section         = build_header + build_declarations                             # type: str
        main_section        = TsfComposer._build_main_section(sources, translations)        # type: Iterable (Generator)     
        with path.open("w", encoding=encoding) as _f:
            _f.writelines(TsfComposer._get_as_iterable(top_section, main_section))
    
    @staticmethod 
    def _process_header(header: str = HEADER_DEFINITION, slice_size: int = 115):
        """Procesa el header y lo procesa con los símbolos de comentario y parte en porciones de texto corta para mejor lectura.
        Devuelve un único string
        """
        splited_header = (header[i:i + slice_size] for i in range(0, len(header), slice_size))
        return "\n".join(f"{TsfComposer.COMMENT_SYMBOL} {part}" for part in splited_header)
    
    @staticmethod
    def _process_declarations(source_lang, time_fmt: str = "%Y-%m-%d || %H:%M:%S"): 
        """Crea las declaraciones del tsf y las devuelve como string procesado y concatenado.
        ``Ver estructura típica de un tsf_file``. Crea algo así como:
        
        ```
            ============================
            *[Sources language: "xx_XX"]
            *[Edited on: ]
            ============================
        ```
        """
        #! Mas tarde se podrá pasar un diccionario con la forma {label:value} si se quiere crear un declarador personalizado
        lang_decl = TsfComposer.DECLARATION_TYPE.format("Source language (locale)", source_lang)
        time_decl = TsfComposer.DECLARATION_TYPE.format("Created in", strftime(time_fmt))
        separator = f"{TsfComposer.LINES_SEPARATOR * len(lang_decl)}{TsfComposer.NEWLINE}" # seeing above example this generates: ======================(\n)
 
        return (
            f"{TsfComposer.NEWLINE}{separator}" 
            f"{lang_decl}{TsfComposer.NEWLINE}"
            f"{time_decl}{TsfComposer.NEWLINE}"
            f"{separator}"
        )
        # contatenated strings (\n, separator, \n, dcls, \n, separator, \n)     
    
    @staticmethod
    def _create_group(_id: int, source: str, translation: str):
        """Crea un grupo con el par source-translation.
        ``Ver estructura típica de un tsf_file``. Crea algo así como:
        
        ```
            @[ID:2]                                  # GROUP_PRIMARY_SELECTOR + NEWLINE
            [SOURCE::2]                              # GROUP_PRIMARY_SELECTOR + NEWLINE
            commodo sed egestas egestas fringilla.   # NEWLINE
            --                                       # GROUP_PARTIAL_SEPARATOR
            [TRANSLATION::2]                         # GROUP_PRIMARY_SELECTOR + NEWLINE
            commodo sed egestas egestas fringilla. # NEWLINE
            --
        ```
        """
        group_selector       = TsfComposer.GROUP_IDENTIFICATOR_SELECTOR.format(_id) + TsfComposer.NEWLINE
        source_selector      = TsfComposer.GROUP_SPECIFIC_SELECTOR.format("SOURCE", _id) + TsfComposer.NEWLINE
        translation_selector = TsfComposer.GROUP_SPECIFIC_SELECTOR.format("TRANSLATION", _id) + TsfComposer.NEWLINE
        translation += f"{TsfComposer.NEWLINE}{TsfComposer.GROUP_PARTIAL_SEPARATOR}"    #anadimos el separador
        source      += f"{TsfComposer.NEWLINE}{TsfComposer.GROUP_PARTIAL_SEPARATOR}"
        return (
            f"{group_selector}"
            f"{source_selector}{source}{TsfComposer.NEWLINE}"
            f"{translation_selector}{translation}{TsfComposer.NEWLINE}"
        )    # el padding lo ponemos en _build_main_section a cada grupo en lugar de hacerlo individualmente
        
    @staticmethod
    def _build_main_section(sources: Iterable, translations: Iterable):
        """Genera un grupo para cada par source-translation y devuelve un generador con los grupos procesados.
        Como esta funcion puede ser algo costosa para la creacion de muchos grupos, devolvemos un iterable"""
        if not translations:        # puede que no se pasen translations en el momento de crealo y se ponen luego
            build_groups = (TsfComposer._create_group(idx, source, " ") for idx, source in enumerate(sources))
        else:
            build_groups = (
                TsfComposer._create_group(idx, source, translation)
                for idx, (source, translation) in enumerate(zip(sources, translations))
            )
        return (
            group + TsfComposer.NEWLINE * TsfComposer.PADDING_BETWEEN_GROUPS for group in build_groups
        )       # anadimos el padding a cada grupo por debajo de ellos (bottom)
        
            
    @staticmethod
    def _get_as_iterable(top_section: str, main_section: str, bottom_section: str = None, details: str = None):
        """Devuelve un iterable que junta toda la estructura de un archivo tsf normal ``(top_section, main_section, bottom_section + details)``
        en una sola string, con la intención de poder introducir
        en los archivos con ``TextIO.writelines()``"""
        
        if isinstance(main_section, Iterable):
            main_section = "".join(main_section) 
        sections = [top_section, main_section]
        if bottom_section is not None:
            sections.append(bottom_section)
        if details is not None:
            sections.append(details)
        sections.append(f"{TsfComposer.NEWLINE * 4}{TsfComposer.EOF}")      # anadimos el EOF -> Dejamos 2 saltos de linea de lineas en blanco
        return iter(sections)                                               # empaquetamos todo en un iterable con el texto
        
    @staticmethod
    def insert_translations(tsf_file: Path, translations: Iterable, encoding: str = "utf-8"):
        parser = Parser(tsf_file, encoding=encoding)
        ...
    
    @staticmethod
    def get_translations(tsf_file: Path, to_tuple: bool = False,  encoding: str = "utf-8"):
        parser = Parser(tsf_file, encoding=encoding)
        ...
        
    @staticmethod
    def to_json(tsf_file: Path, encoding: str = "utf-8"): 
        ...
  
  
  
        
if __name__ == "__main__":

    TsfComposer.create(
        Path("test.tsf"), 
        ["amet", "nisl", "suscipit", "adipiscing", "bibendum", "ultricies" ,"integer"],
        ["asda", "niasdasdsdasl", "suscasdasdasdasdipit", "adiasdasdasdpiscing", "bibenasdasdasdum", "ultricasdasdies" ,"integasdasder"],
        "lat_LAT"
        )